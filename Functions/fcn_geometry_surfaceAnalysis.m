function [drivable_grids,non_drivable_grids,unmapped_grids,gridCenters_mapped_grids,drivable_grid_numbers_in_mapped_grids,...
    non_drivable_grid_numbers_in_mapped_grids,angle_btw_unit_normals_and_vertical,standard_deviation_in_z,...
    unmapped_gridlines,mapped_gridlines,drivable_gridlines,non_drivable_gridlines,gridCenters_unmapped_grids,mean_z_height_of_mapped_grids]... 
= fcn_geometry_surfaceAnalysis(input_points, grid_size, grid_boundaries, point_density, theta_threshold, std_threshold, z_height_threshold, varargin)
%% fcn_geometry_surfaceAnalysis
%
% This function classifies the LiDAR data into mapped and unmapped
% surfaces. Moreover, classifies the mapped data into drivable and
% non-drivable surfaces
%
% FORMAT:
%
% [drivable_grids,non_drivable_grids,unmapped_grids,gridCenters_mapped_grids,drivable_grid_numbers_in_mapped_grids,
% non_drivable_grid_numbers_in_mapped_grids,angle_btw_unit_normals_and_vertical,standard_deviation_in_z]
% = fcn_geometry_surfaceAnalysis(input_points, grid_size, grid_boundaries,
% point_density, theta_threshold, std_threshold, (flag_plot_in_3D),
% (fig_num))
%
% INPUTS:
%
%      input_points: These are points of the data generated by LiDAR.
%      Typically Nx3
%
%      grid_size: size of each grid. 
%
%      grid_boundaries: [min_X,max_X,min_Y,max_Y,min_Z,max_Z]. Typically,
%      these are the minimum and maximum X, Y, Z values of the input data.
%
%      point_density: minimum number of points per each grid. This is used
%      to classify the grid as mapped or unmapped.
%
%      theta_threshold: This is the threshold (upper limit) of angle
%      between the normal of a fitted plane and vertical [0 0 1]. 
%
%      std_threshold: This is the threshold of the standard deviation of
%      the Z coordinates of the points in mapped grids.
%
%      (OPTIONAL INPUTS)
%
%      flag_plot_in_3D: plots the figure in 3D. Takes very long time to
%      plot. 
%
%      fig_num: a figure number to plot results. If set to -1, skips any
%      input checking or debugging, no figures will be generated, and sets
%      up code to maximize speed.
%
% OUTPUTS:
%
%      drivable_grids: These are the original grid numbers of the drivable
%      grids. Original meaning total (mapped and unmmaped) grids together. 
%
%      non_drivable_grids: These are the original grid numbers of the
%      non-drivable grids. Original meaning total (mapped and unmmaped)
%      grids together.
%
%      unmapped_grids: These are the grid numbers of unmapped grids. The
%      grids are classified as unmapped when the point density of the grid
%      is lower than the input point density
%
%      gridCenters_mapped_grids: These are the grid centers of all the
%      mapped and unmapped grids. This matrix also contains the information
%      of drivable and non-drivable surfaces. 
%      OUTPUT FORMAT: [X_center, Y_center, Z_center, 0(non-drivable) or
%      1(drivable)]
%
%      drivable_grid_numbers_in_mapped_grids: These are drivable grid
%      numbers in the mapped grids.
%
%      non_drivable_grid_numbers_in_mapped_grids:These are non-drivable
%      grid numbers in the mapped grids.
%
%      angle_btw_unit_normals_and_vertical: These are the angles(in rad)
%      between the unit normals of the fitted plane and vertical of all the
%      mapped grids
%
%      standard_deviation_in_z: These are the standard deviation of Z
%      coordinate of all the points in each grid
%      
% DEPENDENCIES:
%
%      fcn_geometry_separatePointsIntoGrids
%      fcn_geometry_findRepeatedIndices
%      fcn_geometry_createGridPointIndicesCellArray
%
% EXAMPLES:
%
% See the script: script_test_fcn_geometry_surfaceAnalysis
% for a full test suite.

% This function was written on 2024_06_17 by Aneesh Batchu
% Questions or comments? abb6486@psu.edu or sbrennan@psu.edu 

% Revision history:
% 2024_06_15 - Aneesh Batchu
% -- wrote the code
% 2024_06_25 - Aneesh Batchu
% -- NaNs from gridIndices are removed before they are used in the surface
% analysis
% 2024_06_26 - Aneesh Batchu
% -- Added "angle_btw_unit_normals_and_vertical" and "standard_deviation_in_z" as the outputs
% 2024_06_28 - Aneesh Batchu
% -- Added "gridlines of the mapped, unmapped, drivable, and non-drivable
% gridlines" as the inputs
% -- Changed the plotting into internal functions
% 2024_07_08 - Aneesh Batchu
% -- Added "z_height_threshold" as the input and
% "mean_z_height_of_mapped_grids" as the output. 
% 2024_07_09 - Aneesh Batchu

%% Debugging and Input checks

% Check if flag_max_speed set. This occurs if the fig_num variable input
% argument (varargin) is given a number of -1, which is not a valid figure
% number.
flag_max_speed = 0;
if (nargin==9 && isequal(varargin{end},-1))
    flag_do_debug = 0; % Flag to plot the results for debugging
    flag_check_inputs = 0; % Flag to perform input checking
    flag_max_speed = 1;
else
    % Check to see if we are externally setting debug mode to be "on"
    flag_do_debug = 0; % Flag to plot the results for debugging
    flag_check_inputs = 1; % Flag to perform input checking
    MATLABFLAG_GEOMETRY_FLAG_CHECK_INPUTS = getenv("MATLABFLAG_GEOMETRY_FLAG_CHECK_INPUTS");
    MATLABFLAG_GEOMETRY_FLAG_DO_DEBUG = getenv("MATLABFLAG_GEOMETRY_FLAG_DO_DEBUG");
    if ~isempty(MATLABFLAG_GEOMETRY_FLAG_CHECK_INPUTS) && ~isempty(MATLABFLAG_GEOMETRY_FLAG_DO_DEBUG)
        flag_do_debug = str2double(MATLABFLAG_GEOMETRY_FLAG_DO_DEBUG);
        flag_check_inputs  = str2double(MATLABFLAG_GEOMETRY_FLAG_CHECK_INPUTS);
    end
end

if flag_do_debug
    st = dbstack; %#ok<*UNRCH>
    fprintf(1,'STARTING function: %s, in file: %s\n',st(1).name,st(1).file);
    debug_fig_num = 34838; %#ok<NASGU>
else
    debug_fig_num = []; %#ok<NASGU>
end

%% check input arguments
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   _____                   _
%  |_   _|                 | |
%    | |  _ __  _ __  _   _| |_ ___
%    | | | '_ \| '_ \| | | | __/ __|
%   _| |_| | | | |_) | |_| | |_\__ \
%  |_____|_| |_| .__/ \__,_|\__|___/
%              | |
%              |_|
% See: http://patorjk.com/software/taag/#p=display&f=Big&t=Inputs
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

if 0==flag_max_speed
    if flag_check_inputs
        % Are there the right number of inputs?
        narginchk(7,9);
        % Test if is numeric input
        if ~isnumeric(input_points)
            error('The inputPoints must be numeric')
        end
        size_of_points = size(input_points);
        if size_of_points(2)<1 || size_of_points(2)>3
            error('Gridding only allowed for 1D, 2D, or 3D points.')
        end

        % Check the gridSize input
        fcn_DebugTools_checkInputsToFunctions(grid_size, 'positive_1column_of_numbers',1);


        % Check the size_of_vector input

        % Test if is numeric input
        if ~isnumeric(grid_boundaries)
            error('The gridBoundaries must be numeric')
        end
        size_of_vector = size(grid_boundaries);
        if ~isequal(size_of_vector,[1 2*size_of_points(2)])
            error('The gridBoundaries must have dimension of [1 x 2*N] where N is the dimension, in format of: [low_x high_x low_y high_y low_z high_z]')
        end
    end
end

% Does user want to plot in 3D?
flag_plot_in_3D = 0;
if (8<=nargin)
    temp = varargin{1};
    if ~isempty(temp)
        flag_plot_in_3D = temp;
        if flag_plot_in_3D~= 0 && flag_plot_in_3D~= 1 
            error('The flag_plot_in_3D should be either 1 or 0')
        end
    end
end

% Does user want to specify fig_num?
fig_num = []; % Default is to have no figure
flag_do_plots = 0;
if (0==flag_max_speed) && (9<= nargin)
    temp = varargin{end};
    if ~isempty(temp)
        fig_num = temp;
        flag_do_plots = 1;
    end
end


%% Find the grids
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   __  __       _
%  |  \/  |     (_)
%  | \  / | __ _ _ _ __
%  | |\/| |/ _` | | '_ \
%  | |  | | (_| | | | | |
%  |_|  |_|\__,_|_|_| |_|
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Divides the data into grids
[gridIndices,grid_AABBs,gridCenters] = fcn_geometry_separatePointsIntoGrids(input_points, grid_size, grid_boundaries, (-1));

% Remove NaNs from gridIndices if there any
gridIndices = gridIndices(~isnan(gridIndices));

% Calculate the number of points in each grid
total_N_points_in_each_grid = fcn_geometry_findRepeatedIndices(gridIndices,length(grid_AABBs(:,1)), -1);

% Save all the indices to a cell array. Each cell contains the indices of
% the inputPoints that belong to the grid. 
gridIndices_cell_array = fcn_geometry_createGridPointIndicesCellArray(gridIndices,length(grid_AABBs(:,1)),-1);

% Unmapped/not_fitted grids. These grids do not contain enough number of
% points to fit a plane and classify it as drivable or non-drivable
original_unmapped_grid_numbers = find(total_N_points_in_each_grid(:,1) < point_density); 

% Output
unmapped_grids = original_unmapped_grid_numbers; 

% Grid centers of unmapped grids
gridCenters_unmapped_grids = [gridCenters(unmapped_grids,1), gridCenters(unmapped_grids,2), gridCenters(unmapped_grids,3), zeros(length(unmapped_grids),1)]; 

% Mapped grids. Later these grids are classified into drivable and non
% drivable
original_mapped_grid_numbers = find(total_N_points_in_each_grid(:,1) >= point_density); 

% The indices of the mapped grids are extracted and concatenated 
original_mapped_grids = gridIndices_cell_array(original_mapped_grid_numbers); 

% % Indices of points in mapped grids
% indices_original_mapped_grids = vertcat(original_mapped_grids{:}); 
% 
% % Input points in the mapped grids
% points_in_original_mapped_grids = input_points(indices_original_mapped_grids,:); 

% Total number of mapped grids
total_mapped_grids = length(original_mapped_grids); 

% Parameters of the plane fits of each mapped grid
parameters_of_fitted_plane = zeros(total_mapped_grids,3); 

% Unit normal vectors of the plane fits of each mapped grid
unit_normal_vectors = zeros(total_mapped_grids,3); 

% Standard deviations in orthogonal distances of points in the grid to
% plane
% standard_deviation_in_plane_orthogonals = zeros(total_mapped_grids,1); 
standard_deviation_in_z = zeros(total_mapped_grids,1); 

% z_height of all the points 
mean_z_height_of_mapped_grids = zeros(total_mapped_grids,1); 

% Loop through all the combos, recording agreement with each combo
if 0==flag_max_speed
    h_waitbar = waitbar(0,'Performing surface analysis...');
end
% A loop that iterates based on the length of mapped grids and fits the
% plane to each mapped grid
for ith_mapped_grid = 1:total_mapped_grids
    % [parameters, standard_deviation_in_z(ith_mapped_grid,:), z_fit, unit_normal_vectors(ith_mapped_grid,:), base_point, standard_deviation_in_plane_orthogonals(ith_mapped_grid,:)] = fcn_geometry_fitPlaneLinearRegression(input_points(original_mapped_grids{ith_mapped_grid},:),-1);
    % [parameters, ~, ~, unit_normal_vectors(ith_mapped_grid,:), ~, standard_deviation_in_plane_orthogonals(ith_mapped_grid,:)] = fcn_geometry_fitPlaneLinearRegression(input_points(original_mapped_grids{ith_mapped_grid},:),-1);
    [parameters, standard_deviation_in_z(ith_mapped_grid,:), ~, unit_normal_vectors(ith_mapped_grid,:), ~, ~] = fcn_geometry_fitPlaneLinearRegression(input_points(original_mapped_grids{ith_mapped_grid},:),-1);
    parameters_of_fitted_plane(ith_mapped_grid,:) = parameters';
    mean_z_height_of_mapped_grids(ith_mapped_grid,:) = mean(input_points(original_mapped_grids{ith_mapped_grid},3)); 
    % standard_deviation_in_z(ith_mapped_grid,:) = std(input_points(original_mapped_grids{ith_mapped_grid},3));
end

% Plane analysis: setting thresholds
if ~isempty(theta_threshold) && isempty(std_threshold) && isempty(z_height_threshold)

    % STEP 1
    % Comparing normal vector with verticle direction
    unit_vector_vertical_direction = [0 0 1];

    % The dot product is computed to find the angle between the vectors
    dot_product = sum(unit_normal_vectors.*unit_vector_vertical_direction,2);

    % The angle between unit vertical and the unit_normal_vector is computed to
    % determine how close the normal vector is to vertical direction.
    angle_btw_unit_normals_and_vertical = acos(dot_product);

    % Find the grids (with a fitted plane) that are within the vertical
    % threshold (change to a different name: vertical threshold)
    mapped_grids_within_vertical_threshold = angle_btw_unit_normals_and_vertical < theta_threshold;

    % Grids that satisy the conditions (STEP 1). The grids that
    % are within the vertical threshold
    mapped_grids_within_vertical_and_std_thresholds = (mapped_grids_within_vertical_threshold == 1);

elseif isempty(theta_threshold) && ~isempty(std_threshold) && isempty(z_height_threshold)

    % STEP 2: Standard deviation of the orthogonal (perpendicular) distances of
    % the points to the plane (after fit)
    % Find the grids that are within standard deviation limit
    % This is not enough (delta Y) is also important
    % mapped_grids_within_std_threshold = standard_deviation_in_plane_orthogonals < std_threshold;
    mapped_grids_within_std_threshold = standard_deviation_in_z < std_threshold;

    % Grids that satisy the conditions (STEP 2). The grids that
    % are within the std threshold
    mapped_grids_within_vertical_and_std_thresholds = (mapped_grids_within_std_threshold == 1);

    % The angle between unit vertical and the unit_normal_vector is computed to
    % determine how close the normal vector is to vertical direction.
    angle_btw_unit_normals_and_vertical = [];

elseif isempty(theta_threshold) && isempty(std_threshold) && ~isempty(z_height_threshold)

    % STEP 3: Compare the mean of Z height of each grid with the z_height threshold
    mapped_grids_within_z_height_threshold = (mean_z_height_of_mapped_grids > z_height_threshold(1)) & (mean_z_height_of_mapped_grids < z_height_threshold(2));

    % Grids that satisy both the conditions (STEP 1 and STEP 2). The grids that
    % are within the vertical and std threshold
    mapped_grids_within_vertical_and_std_thresholds = (mapped_grids_within_z_height_threshold == 1);

    % The angle between unit vertical and the unit_normal_vector is computed to
    % determine how close the normal vector is to vertical direction.
    angle_btw_unit_normals_and_vertical = [];
else
    % STEP 1
    % Comparing normal vector with verticle direction
    unit_vector_vertical_direction = [0 0 1];

    % The dot product is computed to find the angle between the vectors
    dot_product = sum(unit_normal_vectors.*unit_vector_vertical_direction,2);

    % The angle between unit vertical and the unit_normal_vector is computed to
    % determine how close the normal vector is to vertical direction.
    angle_btw_unit_normals_and_vertical = acos(dot_product);

    % Find the grids (with a fitted plane) that are within the vertical
    % threshold (change to a different name: vertical threshold)
    mapped_grids_within_vertical_threshold = angle_btw_unit_normals_and_vertical < theta_threshold;

    % STEP 2: Standard deviation of the orthogonal (perpendicular) distances of
    % the points to the plane (after fit)
    % Find the grids that are within standard deviation limit
    % This is not enough (delta Y) is also important
    % mapped_grids_within_std_threshold = standard_deviation_in_plane_orthogonals < std_threshold;
    mapped_grids_within_std_threshold = standard_deviation_in_z < std_threshold;

    if ~isempty(z_height_threshold)
        % STEP 3: Compare the mean of Z height of each grid with the z_height threshold
        mapped_grids_within_z_height_threshold = (mean_z_height_of_mapped_grids > z_height_threshold(1)) & (mean_z_height_of_mapped_grids < z_height_threshold(2));

        % Grids that satisy both the conditions (STEP 1 and STEP 2). The grids that
        % are within the vertical and std threshold
        mapped_grids_within_vertical_and_std_thresholds = (mapped_grids_within_vertical_threshold == 1) & (mapped_grids_within_std_threshold == 1) & (mapped_grids_within_z_height_threshold == 1);
    else
        mapped_grids_within_vertical_and_std_thresholds = (mapped_grids_within_vertical_threshold == 1) & (mapped_grids_within_std_threshold == 1);
    end
end
% Find the drivable grids (original)
drivable_grids = original_mapped_grid_numbers(mapped_grids_within_vertical_and_std_thresholds); 

% Find the non-drivable grids (original)
non_drivable_grids = original_mapped_grid_numbers(mapped_grids_within_vertical_and_std_thresholds == 0);

% Final drivable grid numbers of the mapped grids
drivable_grid_numbers_in_mapped_grids = find(ismember(original_mapped_grid_numbers, drivable_grids));

% Final non drivable grid numbers of the mapped grids
non_drivable_grid_numbers_in_mapped_grids = find(ismember(original_mapped_grid_numbers, non_drivable_grids));

% Grid centers of drivable grids 
gridCenters_drivable_grids = [gridCenters(drivable_grids,1), gridCenters(drivable_grids,2), gridCenters(drivable_grids,3), ones(length(drivable_grids),1)]; 

% Grid centers of nondrivable grids
gridCenters_non_drivable_grids = [gridCenters(non_drivable_grids,1), gridCenters(non_drivable_grids,2), gridCenters(non_drivable_grids,3), zeros(length(non_drivable_grids),1)]; 

% Concatenate the grid centers of drivable and non-drivable grids (2D)
gridCenters_mapped_grids = [gridCenters_drivable_grids; gridCenters_non_drivable_grids];


if 0==flag_max_speed
    close(h_waitbar)
end


%% Plot the results (for debugging)?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   _____       _                 
%  |  __ \     | |                
%  | |  | | ___| |__  _   _  __ _ 
%  | |  | |/ _ \ '_ \| | | |/ _` |
%  | |__| |  __/ |_) | |_| | (_| |
%  |_____/ \___|_.__/ \__,_|\__, |
%                            __/ |
%                           |___/ 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
if flag_do_plots
    
    fig_num_c = fig_num - 1;
    temp_h = figure(fig_num_c);
    flag_rescale_axis = 0;
    if isempty(get(temp_h,'Children'))
        flag_rescale_axis = 1;
    end
    
    % Plots the mapped and unmapped grids
    unmapped_grid_numbers = unmapped_grids;
    mapped_grid_numbers = original_mapped_grid_numbers;

    [unmapped_gridlines,mapped_gridlines] = fcn_INTERNAL_plotMappedUnmappedGrids(unmapped_grid_numbers,mapped_grid_numbers,grid_AABBs,grid_size,gridIndices,input_points,point_density);
    
    % Make axis slightly larger?
    if flag_rescale_axis
        temp = axis;
        %     temp = [min(points(:,1)) max(points(:,1)) min(points(:,2)) max(points(:,2))];
        axis_range_x = temp(2)-temp(1);
        axis_range_y = temp(4)-temp(3);
        percent_larger = 0.3;
        axis([temp(1)-percent_larger*axis_range_x, temp(2)+percent_larger*axis_range_x,  temp(3)-percent_larger*axis_range_y, temp(4)+percent_larger*axis_range_y]);
    end
   
    temp_h = figure(fig_num);
    flag_rescale_axis = 0;
    if isempty(get(temp_h,'Children'))
        flag_rescale_axis = 1;
    end
    
    % Plots the drivable and non-drivable grids 
    drivable_grid_numbers = drivable_grids;
    non_drivable_grid_numbers = non_drivable_grids;
    [drivable_gridlines,non_drivable_gridlines] = fcn_INTERNAL_plotDrivableNondrivableGrids(drivable_grid_numbers,non_drivable_grid_numbers,grid_AABBs,grid_size,gridCenters_drivable_grids,gridCenters_non_drivable_grids,flag_plot_in_3D);

  
    % Make axis slightly larger?
    if flag_rescale_axis
        temp = axis;
        %     temp = [min(points(:,1)) max(points(:,1)) min(points(:,2)) max(points(:,2))];
        axis_range_x = temp(2)-temp(1);
        axis_range_y = temp(4)-temp(3);
        percent_larger = 0.3;
        axis([temp(1)-percent_larger*axis_range_x, temp(2)+percent_larger*axis_range_x,  temp(3)-percent_larger*axis_range_y, temp(4)+percent_larger*axis_range_y]);
    end


end % Ends check if plotting

if flag_do_debug
    fprintf(1,'ENDING function: %s, in file: %s\n\n',st(1).name,st(1).file);
end

end % Ends main function

%% Functions follow
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   ______                _   _
%  |  ____|              | | (_)
%  | |__ _   _ _ __   ___| |_ _  ___  _ __  ___
%  |  __| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
%  | |  | |_| | | | | (__| |_| | (_) | | | \__ \
%  |_|   \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
%
% See: https://patorjk.com/software/taag/#p=display&f=Big&t=Functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%§

function [unmapped_gridlines,mapped_gridlines] = fcn_INTERNAL_plotMappedUnmappedGrids(unmapped_grid_numbers,mapped_grid_numbers,grid_AABBs,grid_size,gridIndices,input_points,point_density)
%% fcn_geometry_plotMappedUnmappedGrids

% Define the color map
cmap = [
    0, 0, 0;   % Grey
    1, 0.2, 0.2;   % Bright Red
    1, 0, 1 % Magenta
    1, 1, 0 % Yellow
    ];

% cmap = [
%     1, 0.2, 0.2;   % Bright Red
%     1, 0.6, 0.2;   % Bright Orange
%     1, 1, 0.2;     % Bright Yellow
%     0.5, 1, 0.5;   % Bright Green
%     0.2, 1, 0.2;   % Bright Lime Green
%     0.8500, 0.3250, 0.0980;  % Orange Red
%     0.9290, 0.6940, 0.1250;  % Mustard Yellow
%     0.5, 1, 0.5;             % Lime Green
%     0.13, 0.55, 0.13;        % Forest Green
%     0.6350, 0.0780, 0.1840;  % Dark Red
% ];

hold on;
grid on;
axis equal
xlabel('X [m]')
ylabel('Y [m]')
zlabel('Z [m]')
title('Mapped and Unmapped Regions')

plot_3D = 0; 

if plot_3D
    view(3)
    % Plot the unmapped points red
    plot3(points_in_original_unmapped_grids(:,1),points_in_original_unmapped_grids(:,2),points_in_original_unmapped_grids(:,3),'.','MarkerSize',20,'Color',[0.6350 0.0780 0.1840]);
    % Plot the mapped points green
    plot3(points_in_original_mapped_grids(:,1),points_in_original_mapped_grids(:,2),points_in_original_mapped_grids(:,3),'.','MarkerSize',20,'Color',[0.4660 0.6740 0.1880]);
else
    unmapped_gridlines = zeros(11*length(unmapped_grid_numbers),2); 
    n = 0;
    p = 0; 
    q = 0; 
    for ith_domain = 1:length(unmapped_grid_numbers)
        % Get current color
        % current_color = fcn_geometry_fillColorFromNumberOrName(ith_domain);

        % current_color = [0.6350 0.0780 0.1840];
        % Plot current AABB
        current_AABB = grid_AABBs(unmapped_grid_numbers(ith_domain),1:4);

        % Nudge the current AABB inward
        current_AABB = current_AABB + grid_size/100*[1 -1 1 -1];

        % Calculate the gridlines
        gridlines = [...
            current_AABB(1,1) current_AABB(1,3); ...
            current_AABB(1,1) current_AABB(1,4); ...
            nan nan;
            current_AABB(1,2) current_AABB(1,3); ...
            current_AABB(1,2) current_AABB(1,4); ...
            nan nan;
            current_AABB(1,1) current_AABB(1,3); ...
            current_AABB(1,2) current_AABB(1,3); ...
            nan nan;
            current_AABB(1,1) current_AABB(1,4); ...
            current_AABB(1,2) current_AABB(1,4); ...
            ];

        % Plot the unmapped points red
        % p2 = plot(points_in_original_unmapped_grids(:,1),points_in_original_unmapped_grids(:,2),'.','MarkerSize',20,'Color',[0.6350 0.0780 0.1840]);

        % Get all points in this domain and plot them
        rows_in_domain = gridIndices==unmapped_grid_numbers(ith_domain);
        points_in_domain = input_points(rows_in_domain,:);
        
        length_points_in_domain = length(points_in_domain);
        if(isempty(points_in_domain))
            current_color = cmap(1,:);
            n = n+1; 
        elseif (~isempty(points_in_domain) && length_points_in_domain <= point_density)
            p = p+1;
            current_color = cmap(1,:);
            %  elseif (length_points_in_domain > 10 && length_points_in_domain < point_density)
            % 
            % current_color = cmap(2,:);
            % q = q+1;
        end

        length_gridlines = length(gridlines); 
        % Plot the result
        % p2 = plot(gridlines(:,1),gridlines(:,2),'-','Color',current_color,'LineWidth',3);
        plot(gridlines(:,1),gridlines(:,2),'-','Color',current_color,'LineWidth',3);

        unmapped_gridlines(1+(ith_domain-1)*length_gridlines:ith_domain*length_gridlines,:) = gridlines; 


    end
    
    mapped_gridlines = zeros(11*length(mapped_grid_numbers),2); % length(gridlines) = 11
    for ith_domain = 1:length(mapped_grid_numbers)
        % Get current color
        % current_color = fcn_geometry_fillColorFromNumberOrName(ith_domain);

        % current_color = [0.4660 0.6740 0.1880];
        % Plot current AABB
        current_AABB = grid_AABBs(mapped_grid_numbers(ith_domain),1:4);

        % Nudge the current AABB inward
        current_AABB = current_AABB + grid_size/100*[1 -1 1 -1];

        % Calculate the gridlines
        gridlines = [...
            current_AABB(1,1) current_AABB(1,3); ...
            current_AABB(1,1) current_AABB(1,4); ...
            nan nan;
            current_AABB(1,2) current_AABB(1,3); ...
            current_AABB(1,2) current_AABB(1,4); ...
            nan nan;
            current_AABB(1,1) current_AABB(1,3); ...
            current_AABB(1,2) current_AABB(1,3); ...
            nan nan;
            current_AABB(1,1) current_AABB(1,4); ...
            current_AABB(1,2) current_AABB(1,4); ...
            ];

        % Get all points in this domain and plot them
        rows_in_domain = gridIndices==mapped_grid_numbers(ith_domain);
        points_in_domain = input_points(rows_in_domain,:);

        length_points_in_domain = length(points_in_domain);

        if (length_points_in_domain >= point_density && length_points_in_domain <= 2*point_density)
            current_color = cmap(3,:);
        elseif(length_points_in_domain > 2*point_density)
            current_color = cmap(4,:);
        end

        length_gridlines = length(gridlines);
        % % Plot the mapped points green
        % p1 = plot(points_in_original_mapped_grids(:,1),points_in_original_mapped_grids(:,2),'.','MarkerSize',20,'Color',[0.4660 0.6740 0.1880]);

        % Plot the result
        % p1 = plot(gridlines(:,1),gridlines(:,2),'-','Color',current_color,'LineWidth',3);
        plot(gridlines(:,1),gridlines(:,2),'-','Color',current_color,'LineWidth',3);

        mapped_gridlines(1+(ith_domain-1)*length_gridlines:ith_domain*length_gridlines,:) = gridlines;
    end
end

% legend([p1,p2],{'Mapped','Unmapped'})

end % fcn_INTERNAL_plotMappedUnmappedGrids ends here

function [drivable_gridlines,non_drivable_gridlines] = fcn_INTERNAL_plotDrivableNondrivableGrids(drivable_grid_numbers,non_drivable_grid_numbers,grid_AABBs,grid_size,gridCenters_drivable_grids,gridCenters_non_drivable_grids,flag_plot_in_3D)

hold on;
grid on;
axis equal
xlabel('X [m]')
ylabel('Y [m]')
zlabel('Z [m]')
title('Drivable and Non-drivable Regions')

if flag_plot_in_3D

    view(3)

    % Plot all the points
    % plot3(points_in_original_mapped_grids(:,1),points_in_original_mapped_grids(:,2),points_in_original_mapped_grids(:,3),'.','MarkerSize',20,'Color',[0 0 0]);
    
    for ith_domain = 1:length(drivable_grid_numbers)
        % Get current color
        % current_color = fcn_geometry_fillColorFromNumberOrName(ith_domain);
        current_color = [0.4660 0.6740 0.1880];

        % Plot current AABB
        current_AABB = grid_AABBs(drivable_grids(ith_domain),:);

        % Nudge the current AABB inward
        current_AABB = current_AABB + grid_size/100*[1 -1 1 -1 1 -1];

        % Calculate the gridlines
        gridlines = [...
            current_AABB(1,1) current_AABB(1,3) current_AABB(1,5); ...
            current_AABB(1,1) current_AABB(1,3) current_AABB(1,6); ...
            nan nan nan;
            current_AABB(1,1) current_AABB(1,4) current_AABB(1,5); ...
            current_AABB(1,1) current_AABB(1,4) current_AABB(1,6); ...
            nan nan nan;
            current_AABB(1,2) current_AABB(1,3) current_AABB(1,5); ...
            current_AABB(1,2) current_AABB(1,3) current_AABB(1,6); ...
            nan nan nan;
            current_AABB(1,2) current_AABB(1,4) current_AABB(1,5); ...
            current_AABB(1,2) current_AABB(1,4) current_AABB(1,6); ...
            nan nan nan;
            current_AABB(1,1) current_AABB(1,3) current_AABB(1,5); ...
            current_AABB(1,1) current_AABB(1,4) current_AABB(1,5); ...
            nan nan nan;
            current_AABB(1,2) current_AABB(1,3) current_AABB(1,5); ...
            current_AABB(1,2) current_AABB(1,4) current_AABB(1,5); ...
            nan nan nan;
            current_AABB(1,1) current_AABB(1,3) current_AABB(1,6); ...
            current_AABB(1,1) current_AABB(1,4) current_AABB(1,6); ...
            nan nan nan;
            current_AABB(1,2) current_AABB(1,3) current_AABB(1,6); ...
            current_AABB(1,2) current_AABB(1,4) current_AABB(1,6); ...
            nan nan nan;
            current_AABB(1,1) current_AABB(1,3) current_AABB(1,5); ...
            current_AABB(1,2) current_AABB(1,3) current_AABB(1,5); ...
            nan nan nan;
            current_AABB(1,1) current_AABB(1,4) current_AABB(1,5); ...
            current_AABB(1,2) current_AABB(1,4) current_AABB(1,5); ...
            nan nan nan;
            current_AABB(1,1) current_AABB(1,3) current_AABB(1,6); ...
            current_AABB(1,2) current_AABB(1,3) current_AABB(1,6); ...
            nan nan nan;
            current_AABB(1,1) current_AABB(1,4) current_AABB(1,6); ...
            current_AABB(1,2) current_AABB(1,4) current_AABB(1,6); ...
            nan nan nan];

        % Plot the result
        plot3(gridlines(:,1),gridlines(:,2),gridlines(:,3),'-','Color',current_color,'LineWidth',3);


        % Get all points in this domain and plot them
        rows_in_domain = gridIndices==drivable_grids(ith_domain);
        points_in_domain = input_points(rows_in_domain,:);
        plot3(points_in_domain(:,1),points_in_domain(:,2),points_in_domain(:,3),'.','MarkerSize',20,'Color',current_color);

        % plot the grid centers
        plot3(gridCenters_drivable_grids(ith_domain,1), gridCenters_drivable_grids(ith_domain,2), gridCenters_drivable_grids(ith_domain,3), '.','MarkerSize',40,'Color',[0 0 0]);

        % Plot the unit normal vector
        quiver3(gridCenters(drivable_grids(ith_domain),1),gridCenters(drivable_grids(ith_domain),2),gridCenters(drivable_grids(ith_domain),3), unit_normal_vectors(drivable_grid_numbers_in_mapped_grids(ith_domain),1),unit_normal_vectors(drivable_grid_numbers_in_mapped_grids(ith_domain),2),unit_normal_vectors(drivable_grid_numbers_in_mapped_grids(ith_domain),3),0,'g','Linewidth',3);

    end

    for ith_domain = 1:length(non_drivable_grids)
        % Get current color
        % current_color = fcn_geometry_fillColorFromNumberOrName(ith_domain);
        current_color = [0.6350 0.0780 0.1840];

        % Plot current AABB
        current_AABB = grid_AABBs(non_drivable_grids(ith_domain),:);

        % Nudge the current AABB inward
        current_AABB = current_AABB + grid_size/100*[1 -1 1 -1 1 -1];

        % Calculate the gridlines
        gridlines = [...
            current_AABB(1,1) current_AABB(1,3) current_AABB(1,5); ...
            current_AABB(1,1) current_AABB(1,3) current_AABB(1,6); ...
            nan nan nan;
            current_AABB(1,1) current_AABB(1,4) current_AABB(1,5); ...
            current_AABB(1,1) current_AABB(1,4) current_AABB(1,6); ...
            nan nan nan;
            current_AABB(1,2) current_AABB(1,3) current_AABB(1,5); ...
            current_AABB(1,2) current_AABB(1,3) current_AABB(1,6); ...
            nan nan nan;
            current_AABB(1,2) current_AABB(1,4) current_AABB(1,5); ...
            current_AABB(1,2) current_AABB(1,4) current_AABB(1,6); ...
            nan nan nan;
            current_AABB(1,1) current_AABB(1,3) current_AABB(1,5); ...
            current_AABB(1,1) current_AABB(1,4) current_AABB(1,5); ...
            nan nan nan;
            current_AABB(1,2) current_AABB(1,3) current_AABB(1,5); ...
            current_AABB(1,2) current_AABB(1,4) current_AABB(1,5); ...
            nan nan nan;
            current_AABB(1,1) current_AABB(1,3) current_AABB(1,6); ...
            current_AABB(1,1) current_AABB(1,4) current_AABB(1,6); ...
            nan nan nan;
            current_AABB(1,2) current_AABB(1,3) current_AABB(1,6); ...
            current_AABB(1,2) current_AABB(1,4) current_AABB(1,6); ...
            nan nan nan;
            current_AABB(1,1) current_AABB(1,3) current_AABB(1,5); ...
            current_AABB(1,2) current_AABB(1,3) current_AABB(1,5); ...
            nan nan nan;
            current_AABB(1,1) current_AABB(1,4) current_AABB(1,5); ...
            current_AABB(1,2) current_AABB(1,4) current_AABB(1,5); ...
            nan nan nan;
            current_AABB(1,1) current_AABB(1,3) current_AABB(1,6); ...
            current_AABB(1,2) current_AABB(1,3) current_AABB(1,6); ...
            nan nan nan;
            current_AABB(1,1) current_AABB(1,4) current_AABB(1,6); ...
            current_AABB(1,2) current_AABB(1,4) current_AABB(1,6); ...
            nan nan nan];

        % Plot the result
        plot3(gridlines(:,1),gridlines(:,2),gridlines(:,3),'-','Color',current_color,'LineWidth',3);


        % Get all points in this domain and plot them
        rows_in_domain = gridIndices==non_drivable_grids(ith_domain);
        points_in_domain = input_points(rows_in_domain,:);
        plot3(points_in_domain(:,1),points_in_domain(:,2),points_in_domain(:,3),'.','MarkerSize',20,'Color',current_color);

        % plot the grid centers
        plot3(gridCenters_non_drivable_grids(ith_domain,1), gridCenters_non_drivable_grids(ith_domain,2), gridCenters_non_drivable_grids(ith_domain,3), '.','MarkerSize',40,'Color',[0 0 0]);

        % Plot the unit vector
        quiver3(gridCenters(non_drivable_grids(ith_domain),1),gridCenters(non_drivable_grids(ith_domain),2),gridCenters(non_drivable_grids(ith_domain),3), unit_normal_vectors(non_drivable_grid_numbers_in_mapped_grids(ith_domain),1),unit_normal_vectors(non_drivable_grid_numbers_in_mapped_grids(ith_domain),2),unit_normal_vectors(non_drivable_grid_numbers_in_mapped_grids(ith_domain),3),0,'g','Linewidth',3);
    end

else
    % plot(points_in_original_mapped_grids(:,1),points_in_original_mapped_grids(:,2),'.','MarkerSize',20,'Color',[0, 0, 0]);
    
    drivable_gridlines = zeros(11*length(drivable_grid_numbers),2); % length(gridlines) = 11
    % Plot the input points by domain with different colors for each
    % domain
    for ith_domain = 1:length(drivable_grid_numbers)
        % Get current color
        % current_color = fcn_geometry_fillColorFromNumberOrName(ith_domain);

        current_color = [0,1,0];%[0.4660 0.6740 0.1880]; %[0.5, 1, 0.5]; 
        % Plot current AABB
        current_AABB = grid_AABBs(drivable_grid_numbers(ith_domain),1:4);

        % Nudge the current AABB inward
        current_AABB = current_AABB + grid_size/100*[1 -1 1 -1];

        % Calculate the gridlines
        gridlines = [...
            current_AABB(1,1) current_AABB(1,3); ...
            current_AABB(1,1) current_AABB(1,4); ...
            nan nan;
            current_AABB(1,2) current_AABB(1,3); ...
            current_AABB(1,2) current_AABB(1,4); ...
            nan nan;
            current_AABB(1,1) current_AABB(1,3); ...
            current_AABB(1,2) current_AABB(1,3); ...
            nan nan;
            current_AABB(1,1) current_AABB(1,4); ...
            current_AABB(1,2) current_AABB(1,4); ...
            ];
        length_gridlines = length(gridlines); 
        % Plot the result
        p3 = plot(gridlines(:,1),gridlines(:,2),'-','Color',current_color,'LineWidth',3);

        % Plot the grid centers
        % plot(gridCenters(drivable_grids(ith_domain),1), gridCenters(drivable_grids(ith_domain),2), '.','MarkerSize',40,'Color',[0 0 0]);

        % plot(gridCenters_drivable_grids(ith_domain,1), gridCenters_drivable_grids(ith_domain,2), '.','MarkerSize',30,'Color',[0 0 0]);
        % plot(gridCenters_drivable_grids(ith_domain,1), gridCenters_drivable_grids(ith_domain,2), '.','MarkerSize',30,'Color',current_color);
        drivable_gridlines(1+(ith_domain-1)*length_gridlines:ith_domain*length_gridlines,:) = gridlines;
        % % Number the results (for clarity)
        % for ith_label = 1:length(gridCenters_drivable_grids)
        %     label_number = Z_greater_than(ith_label);
        %     current_text = sprintf('%.0d',label_number);
        %     text(X(label_number),Y(label_number),current_text,'Color',[0.5 0.5 0.5],'HorizontalAlignment','center');
        % end

        % Get all points in this domain and plot them
        % rows_in_domain = gridIndices==drivable_grids(ith_domain);
        % points_in_domain = input_points(rows_in_domain,:);

        % plot(points_in_domain(:,1),points_in_domain(:,2),'.','MarkerSize',20,'Color',current_color);
    end
    
    non_drivable_gridlines = zeros(11*length(non_drivable_grid_numbers),2); % length(gridlines) = 11
    % Plot the input points by domain with different colors for each
    % domain
    for ith_domain = 1:length(non_drivable_grid_numbers)
        % Get current color
        % current_color = fcn_geometry_fillColorFromNumberOrName(ith_domain);

        current_color = [0.6350 0.0780 0.1840]; % [1, 0.2, 0.2]; 
        % Plot current AABB
        current_AABB = grid_AABBs(non_drivable_grid_numbers(ith_domain),1:4);

        % Nudge the current AABB inward
        current_AABB = current_AABB + grid_size/100*[1 -1 1 -1];

        % Calculate the gridlines
        gridlines = [...
            current_AABB(1,1) current_AABB(1,3); ...
            current_AABB(1,1) current_AABB(1,4); ...
            nan nan;
            current_AABB(1,2) current_AABB(1,3); ...
            current_AABB(1,2) current_AABB(1,4); ...
            nan nan;
            current_AABB(1,1) current_AABB(1,3); ...
            current_AABB(1,2) current_AABB(1,3); ...
            nan nan;
            current_AABB(1,1) current_AABB(1,4); ...
            current_AABB(1,2) current_AABB(1,4); ...
            ];
        
        length_gridlines = length(gridlines); 
        % Plot the result
        p4 = plot(gridlines(:,1),gridlines(:,2),'-','Color',current_color,'LineWidth',3);


        % Plot the grid centers
        % plot(gridCenters(non_drivable_grids(ith_domain),1), gridCenters(non_drivable_grids(ith_domain),2), '.','MarkerSize',40,'Color',[0 0 0]);

        % plot(gridCenters_non_drivable_grids(ith_domain,1), gridCenters_non_drivable_grids(ith_domain,2), '.','MarkerSize',30,'Color',[0 0 0]);
        % plot(gridCenters_non_drivable_grids(ith_domain,1), gridCenters_non_drivable_grids(ith_domain,2), '.','MarkerSize',30,'Color',current_color);
        non_drivable_gridlines(1+(ith_domain-1)*length_gridlines:ith_domain*length_gridlines,:) = gridlines;
        % Get all points in this domain and plot them
        % rows_in_domain = gridIndices==non_drivable_grids(ith_domain);
        % points_in_domain = input_points(rows_in_domain,:);
        % plot(points_in_domain(:,1),points_in_domain(:,2),'.','MarkerSize',20,'Color',current_color);
    end

    % legend([p3,p4],{'Drivable','Non-drivable'})
    legend([p3,p4],{'Drivable','Non-drivable'})
end

% legend([p3,p4],{'Drivable','Non-drivable'})

end

% [gridCenters_unmapped, gridCenters_mapped_with_low_point_density, gridCenters_mapped, gridCenters_drivable, gridCenters_non_drivable]
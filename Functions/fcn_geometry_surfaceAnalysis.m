function [drivable_grids,non_drivable_grids,unmapped_grids,gridCenters_mapped_grids,drivable_grid_numbers_in_mapped_grids,...
    non_drivable_grid_numbers_in_mapped_grids,angle_btw_unit_normals_and_vertical,standard_deviation_in_z]... 
= fcn_geometry_surfaceAnalysis(input_points, grid_size, grid_boundaries, point_density, theta_threshold, std_threshold, varargin)
%% fcn_geometry_surfaceAnalysis
%
% This function classifies the LiDAR data into mapped and unmapped
% surfaces. Moreover, classifies the mapped data into drivable and
% non-drivable surfaces
%
% FORMAT:
%
% [drivable_grids,non_drivable_grids,unmapped_grids,gridCenters_mapped_grids,drivable_grid_numbers_in_mapped_grids,
% non_drivable_grid_numbers_in_mapped_grids,angle_btw_unit_normals_and_vertical,standard_deviation_in_z]
% = fcn_geometry_surfaceAnalysis(input_points, grid_size, grid_boundaries,
% point_density, theta_threshold, std_threshold, (flag_plot_in_3D),
% (fig_num))
%
% INPUTS:
%
%      input_points: These are points of the data generated by LiDAR.
%      Typically Nx3
%
%      grid_size: size of each grid. 
%
%      grid_boundaries: [min_X,max_X,min_Y,max_Y,min_Z,max_Z]. Typically,
%      these are the minimum and maximum X, Y, Z values of the input data.
%
%      point_density: minimum number of points per each grid. This is used
%      to classify the grid as mapped or unmapped.
%
%      theta_threshold: This is the threshold (upper limit) of angle
%      between the normal of a fitted plane and vertical [0 0 1]. 
%
%      std_threshold: This is the threshold of the standard deviation of
%      the Z coordinates of the points in mapped grids.
%
%      (OPTIONAL INPUTS)
%
%      flag_plot_in_3D: plots the figure in 3D. Takes very long time to
%      plot. 
%
%      fig_num: a figure number to plot results. If set to -1, skips any
%      input checking or debugging, no figures will be generated, and sets
%      up code to maximize speed.
%
% OUTPUTS:
%
%      drivable_grids: These are the original grid numbers of the drivable
%      grids. Original meaning total (mapped and unmmaped) grids together. 
%
%      non_drivable_grids: These are the original grid numbers of the
%      non-drivable grids. Original meaning total (mapped and unmmaped)
%      grids together.
%
%      unmapped_grids: These are the grid numbers of unmapped grids. The
%      grids are classified as unmapped when the point density of the grid
%      is lower than the input point density
%
%      gridCenters_mapped_grids: These are the grid centers of all the
%      mapped and unmapped grids. This matrix also contains the information
%      of drivable and non-drivable surfaces. 
%      OUTPUT FORMAT: [X_center, Y_center, Z_center, 0(non-drivable) or
%      1(drivable)]
%
%      drivable_grid_numbers_in_mapped_grids: These are drivable grid
%      numbers in the mapped grids.
%
%      non_drivable_grid_numbers_in_mapped_grids:These are non-drivable
%      grid numbers in the mapped grids.
%
%      angle_btw_unit_normals_and_vertical: These are the angles(in rad)
%      between the unit normals of the fitted plane and vertical of all the
%      mapped grids
%
%      standard_deviation_in_z: These are the standard deviation of Z
%      coordinate of all the points in each grid
%      
% DEPENDENCIES:
%
%      fcn_geometry_separatePointsIntoGrids
%      fcn_geometry_findRepeatedIndices
%      fcn_geometry_createGridPointIndicesCellArray
%
% EXAMPLES:
%
% See the script: script_test_fcn_geometry_surfaceAnalysis
% for a full test suite.

% This function was written on 2024_06_17 by Aneesh Batchu
% Questions or comments? abb6486@psu.edu or sbrennan@psu.edu 

% Revision history:
% 2024_06_15 - Aneesh Batchu
% -- wrote the code
% 2024_06_25 - Aneesh Batchu
% -- NaNs from gridIndices are removed before they are used in the surface
% analysis
% 2024_06_26 - Aneesh Batchu
% -- Added "angle_btw_unit_normals_and_vertical" and "standard_deviation_in_z" as the outputs

%% Debugging and Input checks

% Check if flag_max_speed set. This occurs if the fig_num variable input
% argument (varargin) is given a number of -1, which is not a valid figure
% number.
flag_max_speed = 0;
if (nargin==8 && isequal(varargin{end},-1))
    flag_do_debug = 0; % Flag to plot the results for debugging
    flag_check_inputs = 0; % Flag to perform input checking
    flag_max_speed = 1;
else
    % Check to see if we are externally setting debug mode to be "on"
    flag_do_debug = 0; % Flag to plot the results for debugging
    flag_check_inputs = 1; % Flag to perform input checking
    MATLABFLAG_GEOMETRY_FLAG_CHECK_INPUTS = getenv("MATLABFLAG_GEOMETRY_FLAG_CHECK_INPUTS");
    MATLABFLAG_GEOMETRY_FLAG_DO_DEBUG = getenv("MATLABFLAG_GEOMETRY_FLAG_DO_DEBUG");
    if ~isempty(MATLABFLAG_GEOMETRY_FLAG_CHECK_INPUTS) && ~isempty(MATLABFLAG_GEOMETRY_FLAG_DO_DEBUG)
        flag_do_debug = str2double(MATLABFLAG_GEOMETRY_FLAG_DO_DEBUG);
        flag_check_inputs  = str2double(MATLABFLAG_GEOMETRY_FLAG_CHECK_INPUTS);
    end
end

if flag_do_debug
    st = dbstack; %#ok<*UNRCH>
    fprintf(1,'STARTING function: %s, in file: %s\n',st(1).name,st(1).file);
    debug_fig_num = 34838; %#ok<NASGU>
else
    debug_fig_num = []; %#ok<NASGU>
end

%% check input arguments
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   _____                   _
%  |_   _|                 | |
%    | |  _ __  _ __  _   _| |_ ___
%    | | | '_ \| '_ \| | | | __/ __|
%   _| |_| | | | |_) | |_| | |_\__ \
%  |_____|_| |_| .__/ \__,_|\__|___/
%              | |
%              |_|
% See: http://patorjk.com/software/taag/#p=display&f=Big&t=Inputs
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

if 0==flag_max_speed
    if flag_check_inputs
        % Are there the right number of inputs?
        narginchk(6,8);
        % Test if is numeric input
        if ~isnumeric(input_points)
            error('The inputPoints must be numeric')
        end
        size_of_points = size(input_points);
        if size_of_points(2)<1 || size_of_points(2)>3
            error('Gridding only allowed for 1D, 2D, or 3D points.')
        end

        % Check the gridSize input
        fcn_DebugTools_checkInputsToFunctions(grid_size, 'positive_1column_of_numbers',1);


        % Check the size_of_vector input

        % Test if is numeric input
        if ~isnumeric(grid_boundaries)
            error('The gridBoundaries must be numeric')
        end
        size_of_vector = size(grid_boundaries);
        if ~isequal(size_of_vector,[1 2*size_of_points(2)])
            error('The gridBoundaries must have dimension of [1 x 2*N] where N is the dimension, in format of: [low_x high_x low_y high_y low_z high_z]')
        end
    end
end

% Does user want to plot in 3D?
flag_plot_in_3D = 0;
if (7<=nargin)
    temp = varargin{1};
    if ~isempty(temp)
        flag_plot_in_3D = temp;
        if flag_plot_in_3D~= 0 && flag_plot_in_3D~= 1 
            error('The flag_plot_in_3D should be either 1 or 0')
        end
    end
end

% Does user want to specify fig_num?
fig_num = []; % Default is to have no figure
flag_do_plots = 0;
if (0==flag_max_speed) && (8<= nargin)
    temp = varargin{end};
    if ~isempty(temp)
        fig_num = temp;
        flag_do_plots = 1;
    end
end


%% Find the grids
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   __  __       _
%  |  \/  |     (_)
%  | \  / | __ _ _ _ __
%  | |\/| |/ _` | | '_ \
%  | |  | | (_| | | | | |
%  |_|  |_|\__,_|_|_| |_|
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Divides the data into grids
[gridIndices,grid_AABBs,gridCenters] = fcn_geometry_separatePointsIntoGrids(input_points, grid_size, grid_boundaries, (-1));

% Remove NaNs from gridIndices if there any
gridIndices = gridIndices(~isnan(gridIndices));

% Calculate the number of points in each grid
total_N_points_in_each_grid = fcn_geometry_findRepeatedIndices(gridIndices,length(grid_AABBs(:,1)), -1);

% Save all the indices to a cell array. Each cell contains the indices of
% the inputPoints that belong to the grid. 
gridIndices_cell_array = fcn_geometry_createGridPointIndicesCellArray(gridIndices,length(grid_AABBs(:,1)),-1);

% Unmapped/not_fitted grids. These grids do not contain enough number of
% points to fit a plane and classify it as drivable or non-drivable
original_unmapped_grid_numbers = find(total_N_points_in_each_grid(:,1) < point_density); 

% Output
unmapped_grids = original_unmapped_grid_numbers; 

% Mapped grids. Later these grids are classified into drivable and non
% drivable
original_mapped_grid_numbers = find(total_N_points_in_each_grid(:,1) >= point_density); 

% The indices of the mapped grids are extracted and concatenated 
original_mapped_grids = gridIndices_cell_array(original_mapped_grid_numbers); 

% Indices of points in mapped grids
indices_original_mapped_grids = vertcat(original_mapped_grids{:}); 

% Input points in the mapped grids
points_in_original_mapped_grids = input_points(indices_original_mapped_grids,:); 

% Total number of mapped grids
total_mapped_grids = length(original_mapped_grids); 

% Parameters of the plane fits of each mapped grid
parameters_of_fitted_plane = zeros(total_mapped_grids,3); 

% Unit normal vectors of the plane fits of each mapped grid
unit_normal_vectors = zeros(total_mapped_grids,3); 

% Standard deviations in orthogonal distances of points in the grid to
% plane
% standard_deviation_in_plane_orthogonals = zeros(total_mapped_grids,1); 
standard_deviation_in_z = zeros(total_mapped_grids,1); 


% Loop through all the combos, recording agreement with each combo
if 0==flag_max_speed
    h_waitbar = waitbar(0,'Performing surface analysis...');
end
% A loop that iterates based on the length of mapped grids and fits the
% plane to each mapped grid
for ith_mapped_grid = 1:total_mapped_grids
    % [parameters, standard_deviation_in_z(ith_mapped_grid,:), z_fit, unit_normal_vectors(ith_mapped_grid,:), base_point, standard_deviation_in_plane_orthogonals(ith_mapped_grid,:)] = fcn_geometry_fitPlaneLinearRegression(input_points(original_mapped_grids{ith_mapped_grid},:),-1);
    % [parameters, ~, ~, unit_normal_vectors(ith_mapped_grid,:), ~, standard_deviation_in_plane_orthogonals(ith_mapped_grid,:)] = fcn_geometry_fitPlaneLinearRegression(input_points(original_mapped_grids{ith_mapped_grid},:),-1);
    [parameters, ~, ~, unit_normal_vectors(ith_mapped_grid,:), ~, ~] = fcn_geometry_fitPlaneLinearRegression(input_points(original_mapped_grids{ith_mapped_grid},:),-1);
    parameters_of_fitted_plane(ith_mapped_grid,:) = parameters';
    standard_deviation_in_z(ith_mapped_grid,:) = std(input_points(original_mapped_grids{ith_mapped_grid},3));
end

% Plane analysis: setting thresholds

% STEP 1
% Comparing normal vector with verticle direction
unit_vector_vertical_direction = [0 0 1];

% The dot product is computed to find the angle between the vectors
dot_product = sum(unit_normal_vectors.*unit_vector_vertical_direction,2); 

% The angle between unit vertical and the unit_normal_vector is computed to
% determine how close the normal vector is to vertical direction.
angle_btw_unit_normals_and_vertical = acos(dot_product); 

% Find the grids (with a fitted plane) that are within the vertical
% threshold (change to a different name: vertical threshold)
mapped_grids_within_vertical_threshold = angle_btw_unit_normals_and_vertical < theta_threshold;

% STEP 2: Standard deviation of the orthogonal (perpendicular) distances of
% the points to the plane (after fit) 
% Find the grids that are within standard deviation limit
% This is not enough (delta Y) is also important
% mapped_grids_within_std_threshold = standard_deviation_in_plane_orthogonals < std_threshold; 
mapped_grids_within_std_threshold = standard_deviation_in_z < std_threshold; 

% Grids that satisy both the conditions (STEP 1 and STEP 2). The grids that
% are within the vertical and std threshold
mapped_grids_within_vertical_and_std_thresholds = (mapped_grids_within_vertical_threshold == 1) & (mapped_grids_within_std_threshold == 1);

% Find the drivable grids (original)
drivable_grids = original_mapped_grid_numbers(mapped_grids_within_vertical_and_std_thresholds); 

% Find the non-drivable grids (original)
non_drivable_grids = original_mapped_grid_numbers(mapped_grids_within_vertical_and_std_thresholds == 0);

% Final drivable grid numbers of the mapped grids
drivable_grid_numbers_in_mapped_grids = find(ismember(original_mapped_grid_numbers, drivable_grids));

% Final non drivable grid numbers of the mapped grids
non_drivable_grid_numbers_in_mapped_grids = find(ismember(original_mapped_grid_numbers, non_drivable_grids));

% Grid centers of drivable grids (2D)
gridCenters_drivable_grids = [gridCenters(drivable_grids,1), gridCenters(drivable_grids,2), gridCenters(drivable_grids,3), ones(length(drivable_grids),1)]; 

% Grid centers of nondrivable grids (2D)
gridCenters_non_drivable_grids = [gridCenters(non_drivable_grids,1), gridCenters(non_drivable_grids,2), gridCenters(non_drivable_grids,3), zeros(length(non_drivable_grids),1)]; 

% Concatenate the grid centers of drivable and non-drivable grids (2D)
gridCenters_mapped_grids = [gridCenters_drivable_grids; gridCenters_non_drivable_grids]; 

if 0==flag_max_speed
    close(h_waitbar)
end


%% Plot the results (for debugging)?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   _____       _                 
%  |  __ \     | |                
%  | |  | | ___| |__  _   _  __ _ 
%  | |  | |/ _ \ '_ \| | | |/ _` |
%  | |__| |  __/ |_) | |_| | (_| |
%  |_____/ \___|_.__/ \__,_|\__, |
%                            __/ |
%                           |___/ 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
if flag_do_plots

    fig_num_c = fig_num - 1;
    temp_h = figure(fig_num_c);
    flag_rescale_axis = 0;
    if isempty(get(temp_h,'Children'))
        flag_rescale_axis = 1;
    end

    hold on;
    grid on;
    axis equal
    xlabel('X [m]')
    ylabel('Y [m]')
    zlabel('Z [m]')
    title('Mapped and Unmapped regions')
    % legend('Mapped','Unmapped')

    % The indices of the mapped grids are extracted and concatenated
    original_unmapped_grids = gridIndices_cell_array(original_unmapped_grid_numbers);

    % Indices of points in mapped grids
    indices_original_unmapped_grids = vertcat(original_unmapped_grids{:});

    % Input points in the mapped grids
    points_in_original_unmapped_grids = input_points(indices_original_unmapped_grids,:);
    plot_3D = 0;
    if plot_3D
        view(3)
        % Plot the unmapped points red
        plot3(points_in_original_unmapped_grids(:,1),points_in_original_unmapped_grids(:,2),points_in_original_unmapped_grids(:,3),'.','MarkerSize',20,'Color',[0.6350 0.0780 0.1840]);
        % Plot the mapped points green
        plot3(points_in_original_mapped_grids(:,1),points_in_original_mapped_grids(:,2),points_in_original_mapped_grids(:,3),'.','MarkerSize',20,'Color',[0.4660 0.6740 0.1880]);
    else
        % Plot the unmapped points red
        p2 = plot(points_in_original_unmapped_grids(:,1),points_in_original_unmapped_grids(:,2),'.','MarkerSize',20,'Color',[0.6350 0.0780 0.1840]);
        % Plot the mapped points green
        p1 = plot(points_in_original_mapped_grids(:,1),points_in_original_mapped_grids(:,2),'.','MarkerSize',20,'Color',[0.4660 0.6740 0.1880]);
    end

    legend([p1,p2],{'Mapped','Unmapped'})

    % Make axis slightly larger?
    if flag_rescale_axis
        temp = axis;
        %     temp = [min(points(:,1)) max(points(:,1)) min(points(:,2)) max(points(:,2))];
        axis_range_x = temp(2)-temp(1);
        axis_range_y = temp(4)-temp(3);
        percent_larger = 0.3;
        axis([temp(1)-percent_larger*axis_range_x, temp(2)+percent_larger*axis_range_x,  temp(3)-percent_larger*axis_range_y, temp(4)+percent_larger*axis_range_y]);
    end

    % fig_num = 100012;
    % figure(fig_num); clf;

    temp_h = figure(fig_num);
    flag_rescale_axis = 0;
    if isempty(get(temp_h,'Children'))
        flag_rescale_axis = 1;
    end

    hold on;
    grid on;
    axis equal
    xlabel('X [m]')
    ylabel('Y [m]')
    zlabel('Z [m]')
    title('Drivable and Non-drivable regions')

    if flag_plot_in_3D

        view(3)

        % Plot all the points
        plot3(points_in_original_mapped_grids(:,1),points_in_original_mapped_grids(:,2),points_in_original_mapped_grids(:,3),'.','MarkerSize',20,'Color',[0 0 0]);

        for ith_domain = 1:length(drivable_grids)
            % Get current color
            % current_color = fcn_geometry_fillColorFromNumberOrName(ith_domain);
            current_color = [0.4660 0.6740 0.1880];

            % Plot current AABB
            current_AABB = grid_AABBs(drivable_grids(ith_domain),:);

            % Nudge the current AABB inward
            current_AABB = current_AABB + grid_size/100*[1 -1 1 -1 1 -1];

            % Calculate the gridlines
            gridlines = [...
                current_AABB(1,1) current_AABB(1,3) current_AABB(1,5); ...
                current_AABB(1,1) current_AABB(1,3) current_AABB(1,6); ...
                nan nan nan;
                current_AABB(1,1) current_AABB(1,4) current_AABB(1,5); ...
                current_AABB(1,1) current_AABB(1,4) current_AABB(1,6); ...
                nan nan nan;
                current_AABB(1,2) current_AABB(1,3) current_AABB(1,5); ...
                current_AABB(1,2) current_AABB(1,3) current_AABB(1,6); ...
                nan nan nan;
                current_AABB(1,2) current_AABB(1,4) current_AABB(1,5); ...
                current_AABB(1,2) current_AABB(1,4) current_AABB(1,6); ...
                nan nan nan;
                current_AABB(1,1) current_AABB(1,3) current_AABB(1,5); ...
                current_AABB(1,1) current_AABB(1,4) current_AABB(1,5); ...
                nan nan nan;
                current_AABB(1,2) current_AABB(1,3) current_AABB(1,5); ...
                current_AABB(1,2) current_AABB(1,4) current_AABB(1,5); ...
                nan nan nan;
                current_AABB(1,1) current_AABB(1,3) current_AABB(1,6); ...
                current_AABB(1,1) current_AABB(1,4) current_AABB(1,6); ...
                nan nan nan;
                current_AABB(1,2) current_AABB(1,3) current_AABB(1,6); ...
                current_AABB(1,2) current_AABB(1,4) current_AABB(1,6); ...
                nan nan nan;
                current_AABB(1,1) current_AABB(1,3) current_AABB(1,5); ...
                current_AABB(1,2) current_AABB(1,3) current_AABB(1,5); ...
                nan nan nan;
                current_AABB(1,1) current_AABB(1,4) current_AABB(1,5); ...
                current_AABB(1,2) current_AABB(1,4) current_AABB(1,5); ...
                nan nan nan;
                current_AABB(1,1) current_AABB(1,3) current_AABB(1,6); ...
                current_AABB(1,2) current_AABB(1,3) current_AABB(1,6); ...
                nan nan nan;
                current_AABB(1,1) current_AABB(1,4) current_AABB(1,6); ...
                current_AABB(1,2) current_AABB(1,4) current_AABB(1,6); ...
                nan nan nan];

            % Plot the result
            plot3(gridlines(:,1),gridlines(:,2),gridlines(:,3),'-','Color',current_color,'LineWidth',3);


            % Get all points in this domain and plot them
            rows_in_domain = gridIndices==drivable_grids(ith_domain);
            points_in_domain = input_points(rows_in_domain,:);
            plot3(points_in_domain(:,1),points_in_domain(:,2),points_in_domain(:,3),'.','MarkerSize',20,'Color',current_color);
            
            % plot the grid centers
            plot3(gridCenters_drivable_grids(ith_domain,1), gridCenters_drivable_grids(ith_domain,2), gridCenters_drivable_grids(ith_domain,3), '.','MarkerSize',40,'Color',[0 0 0]);

            % Plot the unit normal vector
            quiver3(gridCenters(drivable_grids(ith_domain),1),gridCenters(drivable_grids(ith_domain),2),gridCenters(drivable_grids(ith_domain),3), unit_normal_vectors(drivable_grid_numbers_in_mapped_grids(ith_domain),1),unit_normal_vectors(drivable_grid_numbers_in_mapped_grids(ith_domain),2),unit_normal_vectors(drivable_grid_numbers_in_mapped_grids(ith_domain),3),0,'g','Linewidth',3);

        end

        for ith_domain = 1:length(non_drivable_grids)
            % Get current color
            % current_color = fcn_geometry_fillColorFromNumberOrName(ith_domain);
            current_color = [0.6350 0.0780 0.1840];

            % Plot current AABB
            current_AABB = grid_AABBs(non_drivable_grids(ith_domain),:);

            % Nudge the current AABB inward
            current_AABB = current_AABB + grid_size/100*[1 -1 1 -1 1 -1];

            % Calculate the gridlines
            gridlines = [...
                current_AABB(1,1) current_AABB(1,3) current_AABB(1,5); ...
                current_AABB(1,1) current_AABB(1,3) current_AABB(1,6); ...
                nan nan nan;
                current_AABB(1,1) current_AABB(1,4) current_AABB(1,5); ...
                current_AABB(1,1) current_AABB(1,4) current_AABB(1,6); ...
                nan nan nan;
                current_AABB(1,2) current_AABB(1,3) current_AABB(1,5); ...
                current_AABB(1,2) current_AABB(1,3) current_AABB(1,6); ...
                nan nan nan;
                current_AABB(1,2) current_AABB(1,4) current_AABB(1,5); ...
                current_AABB(1,2) current_AABB(1,4) current_AABB(1,6); ...
                nan nan nan;
                current_AABB(1,1) current_AABB(1,3) current_AABB(1,5); ...
                current_AABB(1,1) current_AABB(1,4) current_AABB(1,5); ...
                nan nan nan;
                current_AABB(1,2) current_AABB(1,3) current_AABB(1,5); ...
                current_AABB(1,2) current_AABB(1,4) current_AABB(1,5); ...
                nan nan nan;
                current_AABB(1,1) current_AABB(1,3) current_AABB(1,6); ...
                current_AABB(1,1) current_AABB(1,4) current_AABB(1,6); ...
                nan nan nan;
                current_AABB(1,2) current_AABB(1,3) current_AABB(1,6); ...
                current_AABB(1,2) current_AABB(1,4) current_AABB(1,6); ...
                nan nan nan;
                current_AABB(1,1) current_AABB(1,3) current_AABB(1,5); ...
                current_AABB(1,2) current_AABB(1,3) current_AABB(1,5); ...
                nan nan nan;
                current_AABB(1,1) current_AABB(1,4) current_AABB(1,5); ...
                current_AABB(1,2) current_AABB(1,4) current_AABB(1,5); ...
                nan nan nan;
                current_AABB(1,1) current_AABB(1,3) current_AABB(1,6); ...
                current_AABB(1,2) current_AABB(1,3) current_AABB(1,6); ...
                nan nan nan;
                current_AABB(1,1) current_AABB(1,4) current_AABB(1,6); ...
                current_AABB(1,2) current_AABB(1,4) current_AABB(1,6); ...
                nan nan nan];

            % Plot the result
            plot3(gridlines(:,1),gridlines(:,2),gridlines(:,3),'-','Color',current_color,'LineWidth',3);


            % Get all points in this domain and plot them
            rows_in_domain = gridIndices==non_drivable_grids(ith_domain);
            points_in_domain = input_points(rows_in_domain,:);
            plot3(points_in_domain(:,1),points_in_domain(:,2),points_in_domain(:,3),'.','MarkerSize',20,'Color',current_color);

             % plot the grid centers
            plot3(gridCenters_non_drivable_grids(ith_domain,1), gridCenters_non_drivable_grids(ith_domain,2), gridCenters_non_drivable_grids(ith_domain,3), '.','MarkerSize',40,'Color',[0 0 0]);

            % Plot the unit vector
            quiver3(gridCenters(non_drivable_grids(ith_domain),1),gridCenters(non_drivable_grids(ith_domain),2),gridCenters(non_drivable_grids(ith_domain),3), unit_normal_vectors(non_drivable_grid_numbers_in_mapped_grids(ith_domain),1),unit_normal_vectors(non_drivable_grid_numbers_in_mapped_grids(ith_domain),2),unit_normal_vectors(non_drivable_grid_numbers_in_mapped_grids(ith_domain),3),0,'g','Linewidth',3);
        end

    else
        plot(points_in_original_mapped_grids(:,1),points_in_original_mapped_grids(:,2),'.','MarkerSize',20,'Color',[0, 0, 0]);

        % Plot the input points by domain with different colors for each
        % domain
        for ith_domain = 1:length(drivable_grids)
            % Get current color
            % current_color = fcn_geometry_fillColorFromNumberOrName(ith_domain);

            current_color = [0.4660 0.6740 0.1880];
            % Plot current AABB
            current_AABB = grid_AABBs(drivable_grids(ith_domain),1:4);

            % Nudge the current AABB inward
            current_AABB = current_AABB + grid_size/100*[1 -1 1 -1];

            % Calculate the gridlines
            gridlines = [...
                current_AABB(1,1) current_AABB(1,3); ...
                current_AABB(1,1) current_AABB(1,4); ...
                nan nan;
                current_AABB(1,2) current_AABB(1,3); ...
                current_AABB(1,2) current_AABB(1,4); ...
                nan nan;
                current_AABB(1,1) current_AABB(1,3); ...
                current_AABB(1,2) current_AABB(1,3); ...
                nan nan;
                current_AABB(1,1) current_AABB(1,4); ...
                current_AABB(1,2) current_AABB(1,4); ...
                ];

            % Plot the result
            p3 = plot(gridlines(:,1),gridlines(:,2),'-','Color',current_color,'LineWidth',3);

            % Plot the grid centers
            % plot(gridCenters(drivable_grids(ith_domain),1), gridCenters(drivable_grids(ith_domain),2), '.','MarkerSize',40,'Color',[0 0 0]);

            plot(gridCenters_drivable_grids(ith_domain,1), gridCenters_drivable_grids(ith_domain,2), '.','MarkerSize',30,'Color',[0 0 0]);

            % Get all points in this domain and plot them
            rows_in_domain = gridIndices==drivable_grids(ith_domain);
            points_in_domain = input_points(rows_in_domain,:);
            plot(points_in_domain(:,1),points_in_domain(:,2),'.','MarkerSize',20,'Color',current_color);
        end

        % Plot the input points by domain with different colors for each
        % domain
        for ith_domain = 1:length(non_drivable_grids)
            % Get current color
            % current_color = fcn_geometry_fillColorFromNumberOrName(ith_domain);

            current_color = [0.6350 0.0780 0.1840];
            % Plot current AABB
            current_AABB = grid_AABBs(non_drivable_grids(ith_domain),1:4);

            % Nudge the current AABB inward
            current_AABB = current_AABB + grid_size/100*[1 -1 1 -1];

            % Calculate the gridlines
            gridlines = [...
                current_AABB(1,1) current_AABB(1,3); ...
                current_AABB(1,1) current_AABB(1,4); ...
                nan nan;
                current_AABB(1,2) current_AABB(1,3); ...
                current_AABB(1,2) current_AABB(1,4); ...
                nan nan;
                current_AABB(1,1) current_AABB(1,3); ...
                current_AABB(1,2) current_AABB(1,3); ...
                nan nan;
                current_AABB(1,1) current_AABB(1,4); ...
                current_AABB(1,2) current_AABB(1,4); ...
                ];

            % Plot the result
            p4 = plot(gridlines(:,1),gridlines(:,2),'-','Color',current_color,'LineWidth',3);


            % Plot the grid centers
            % plot(gridCenters(non_drivable_grids(ith_domain),1), gridCenters(non_drivable_grids(ith_domain),2), '.','MarkerSize',40,'Color',[0 0 0]);

            plot(gridCenters_non_drivable_grids(ith_domain,1), gridCenters_non_drivable_grids(ith_domain,2), '.','MarkerSize',30,'Color',[0 0 0]);

            % Get all points in this domain and plot them
            rows_in_domain = gridIndices==non_drivable_grids(ith_domain);
            points_in_domain = input_points(rows_in_domain,:);
            plot(points_in_domain(:,1),points_in_domain(:,2),'.','MarkerSize',20,'Color',current_color);
        end

        legend([p3,p4],{'Drivable','Non-drivable'})
    end
    % Make axis slightly larger?
    if flag_rescale_axis
        temp = axis;
        %     temp = [min(points(:,1)) max(points(:,1)) min(points(:,2)) max(points(:,2))];
        axis_range_x = temp(2)-temp(1);
        axis_range_y = temp(4)-temp(3);
        percent_larger = 0.3;
        axis([temp(1)-percent_larger*axis_range_x, temp(2)+percent_larger*axis_range_x,  temp(3)-percent_larger*axis_range_y, temp(4)+percent_larger*axis_range_y]);
    end


end % Ends check if plotting

if flag_do_debug
    fprintf(1,'ENDING function: %s, in file: %s\n\n',st(1).name,st(1).file);
end

end % Ends main function

%% Functions follow
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   ______                _   _
%  |  ____|              | | (_)
%  | |__ _   _ _ __   ___| |_ _  ___  _ __  ___
%  |  __| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
%  | |  | |_| | | | | (__| |_| | (_) | | | \__ \
%  |_|   \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
%
% See: https://patorjk.com/software/taag/#p=display&f=Big&t=Functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%ยง